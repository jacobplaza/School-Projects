# -*- coding: utf-8 -*-
"""Problem Set 5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U-gm-HHb9KI4UQ4sdyw0jA7rTP1hXhsN
"""

class Node:
  def __init__(self, data):
    self.data = data
    self.right_child = None
    self.left_child = None


def insert_BTnode(root, node):
  if root is None:
    root = node

  else: 
    if root.data > node.data:
      if root.left_child is None:
        root.left_child = node
      else:
        insert_BTnode(root.left_child, node)
    else:
      if root.right_child is None:
        root.right_child = node
      else:
        insert_BTnode(root.right_child, node)


def make_my_BST (file):
  x = []
  with open(file, 'r') as f:
    for lines in f: 
      x.append(lines.strip())
  #appending all the values which will be in the bst to a list and stripping the newlines
  
  root = Node(x[0])
  #this creates the first node
  x.pop(0)
  #making sure i don't repeat the first value

  for n in x: 
  #iterate through list of data, sending each value to the node and insertion
  #functions and constructing the tree
    insert_BTnode(root, Node(n))
  return root


def BFF_my_BST(BST):
  BFS = []
  #the list which each element of the tree is added to as it is traversed
  queue = []
  #queue of nodes to be traversed
  queue.append(BST)
  #the BST is appended to the queue to begin with

  while len(queue) > 0: 
  #the function is to run while there are items in the queue

    node = queue[0]
    #the first node is just the first item in the queue

    BFS.append(node.data)
    #node appended to the BFS list
    queue.pop(0)
    #popped from the queue

    if node.left_child != None:
      queue.append(node.left_child)
      #append the left child of the node if it exists

    if node.right_child != None:
      queue.append(node.right_child)
      #do the same for the right child
      #this repeats until all the nodes have been traversed and added to the BFS
      #list
  return BFS

def DFS_my_BST(BST):
  unvisited = []
  unvisited.append(BST)

  visited = []
  stack = []

  stack.append(unvisited[0])
  #append the source node of the tree to the top of the stack

  while len(stack) > 0:
    node = stack[0]
    visited.append(node.data)
    stack.pop(0)
    #takes the top item of the stack and adds to the visited list

    adjacent = []
    if node.left_child != None:
      adjacent.append(node.left_child)
    #if there is a left adjacent value, add that to the adjacent list 
    if node.right_child != None:
      adjacent.append(node.right_child)
    #if there is a right adjacent value, add that to the adjacent list
    #creates a list of adjacent nodes

    for n in adjacent: 
      if n not in visited:
        stack.append(n)
    #adds the adjacent nodes to the top of the stack if they are unvisited

  return visited
    #returns the list of visited numbers



test = make_my_BST("/content/PS5_sample.txt")
print(BFF_my_BST(test))
print(DFS_my_BST(test))