# -*- coding: utf-8 -*-
"""Problem Set 1 Jacob Plaza

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UTrP-k6j5nhcsjKHhH-xkemD3wlHQqOH
"""

a = int(input("Input positive integer a: "))
b = int(input("Input positive integer b: "))

def odd_integers_a_b(a,b):
  # first, iterates over a + 1, constructing a list
  integer_list = []
  n = a
  while n != b+1:
    integer_list.append(n)
    n = n + 1
  intlist_len = len(integer_list)
  # then, constructs another list for each element of that list which is odd
  odd_list = []
  for i in range (0, intlist_len):
    if integer_list[i] % 2 != 0:
      odd_list.append(integer_list[i])
  
  integer_sum = sum(odd_list)
  # then, sum all those numbers
  return integer_sum
  # return those
odd_integers_a_b(a,b)

s = str(input("Input a string which is at most 10,000 letters long: "))

def count_string (s):
  #First, splits the string using spaces a delimiter
  s_list = s.split()
  #Then, Constructs a list with only the unique words in the string
  unique_list = []
  for x in s_list:
      if x not in unique_list:
          unique_list.append(x)
  #Then, uses the list of unique terms as keys for a dictionary
  #Sets the value for each key as an integer equal to 0
  string_dict = {}
  u_length = len(unique_list)
  for n in range (0, u_length):
    string_dict.setdefault(unique_list[n], 0)
  #Iterate over the initial list, adding 1 to each value if the key of the value 
  #matches the element from the intial list
  for e in s_list:
    if e in string_dict:
      string_dict[e] += 1
  #Print each key with its value to figure out how many times each term is counted
  for i in string_dict:
    print (i, string_dict[i])

count_string(s)

s = str(input("Input a string which is at most 10,000 letters long: "))

def count_string (s):
  s = s.lower()
  #This code is identical to the one above, except that I made all the terms in the 
  #initial list lowercase, to make it case insensitive.
  s_list = s.split()
  unique_list = []
  for x in s_list:
      if x not in unique_list:
          unique_list.append(x)

  string_dict = {}
  u_length = len(unique_list)
  for n in range (0, u_length):
    string_dict.setdefault(unique_list[n], 0)

  for e in s_list:
    if e in string_dict:
      string_dict[e] += 1

  for i in string_dict:
    print (i, string_dict[i])

count_string(s)

s = str(input("Input a string of at most 200 letters"))
a = int(input("Input integer a: "))
b = int(input("Input integer b: "))
c = int(input("Input integer c: "))
d = int(input("Input integer d: "))
def index_string (s, a, b, c, d): 
  sliced_string_1 = s[a:b+1]
  #I slice the string from a to b, making it b+1 so that b is included
  sliced_string_2 = s[c:d+1]
  #I also slice it from c to d, making it d+1 so that d is included
  print("a: ", s[a])
  print("b: ", s[b])
  print("c: ", s[c])
  print("d: ", s[d])
  # I test what a, b, c, and d are to make sure that my slices are b + d inclusive
  concatenated_string = sliced_string_1 + " " + sliced_string_2
  # I then concatenate both strings by just using + and puting a space " " between
  #them
  #for whatever reason, 97 and 102 return a string that is moved one element to the left
  #but if you put in 98 and 103, it works
  return print(concatenated_string)

index_string(s, a, b, c, d)

